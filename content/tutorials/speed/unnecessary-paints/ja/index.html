{% extends "tutorial.html" %}
{% load mixin from templatefilters %}

{% block pagebreadcrumb %}{{ tut.title }}{% endblock %}

{% block head %}
<style>
.talkinghead:before {
  background-image: url(/static/images/profiles/75/paullewis.75.png);
  background-position: -14px -9px !important;
}

article.tutorial section {
  overflow: visible;
}

article.tutorial .notice.fact {
  position: relative;
  padding-left: 25px;
}
article.tutorial .notice.fact:before {
  position: absolute;
  top: -5px;
  left: -10px;
  text-transform: uppercase;
  -webkit-transform: rotateZ(-30deg);
  -moz-transform: rotateZ(-30deg);
  -o-transform: rotateZ(-30deg);
  -ms-transform: rotateZ(-30deg);
  transform: rotateZ(-30deg);
  /*color: rgb(80, 139, 136);*/
  color: rgb(237, 71, 50);
  font-weight: bold;
  content: "Fact";
}
</style>
{% endblock %}

{% block iscompatible %}
{% endblock %}

{% block html5badge %}
<!-- Your HTML5 badge (tech class icons used in the article) goes here -->
{% endblock %}

{% block share_image %}
<!--<meta itemprop="image" content="images/your_social_sharing_img.png">-->
{% endblock %}


{% block content %}

<!-- Uncomment if this is a bleeding edge feature
  <p>{% include "warning.html" %}</p>
-->
<h2 id="toc-introduction">イントロダクション</h2>

<p>サイトやアプリケーションでの要素の描画は負荷が掛かり、起動時間のパフォーマンスによくない影響を及ぼす可能性があります。この記事では、ブラウザにおいて何が描画のきっかけになるか、そして、実例からどのように不必要な描画を避けることができるかを見ていきましょう。</p>

<h2 id="toc-painting">Painting: A super-quick tour</h2>

<p>One of the major tasks a browser has to perform is converting your DOM and CSS into pixels on the screen, and it does this through a fairly complex process. It starts by reading the markup and from this it creates a DOM tree. It does a similar thing with the CSS and from that it creates the CSSOM. The DOM and CSSOM are then combined and, eventually, we arrive at a structure from which we can start to paint some pixels.</p>

<blockquote class="commentary talkinghead" id="how-works">
    If you want a much deeper insight into how browsers work there's an <a href="http://www.html5rocks.com/en/tutorials/internals/howbrowserswork/">in-depth article here on HTML5 Rocks</a> that you should check out!
</blockquote>

<p>The painting process itself is interesting. In Chrome that combined tree of DOM and CSS is rasterized by some software called <a href="https://code.google.com/p/skia/">Skia</a>. If you've ever played with the <code>canvas</code> element Skia's API would look awfully familiar to you; there are many <code>moveTo</code>- and <code>lineTo</code>-style functions as well as a bunch of more advanced ones. Essentially all the elements that need to be painted are distilled to a collection of Skia calls that can be executed, and the output of is a bunch of bitmaps. These bitmaps are uploaded to the GPU, and the GPU helps out by compositing them together to give us the final picture on screen.</p>

<figure>
  <img src="/static/demos/unnecessary-paints/images/domtopixels.jpg" />
</figure>

<p>The thing to take away is that Skia's workload is directly affected by the styles you apply to your elements. If you use algorithmically heavy styles then Skia is going to have more work to do. <a href="http://www.google.com/+ColtMcAnlis">Colt McAnlis</a> has written an <a href="http://www.html5rocks.com/en/tutorials/speed/css-paint-times/">article on how CSS affects page render weight</a>, so you should read that for more insight.</p>

<p>With all that said, paint work takes time to perform, and if we don’t reduce it we will run over our frame budget of ~16ms. Users will notice that we missed frames and see it as jank, which ultimately hurts the user experience of our app. We really don’t want that, so let’s see what kinds of things cause paint work to be necessary, and what we can do about it.</p>

<h2 id="toc-scrolling">Scrolling</h2>

<p>Whenever you scroll up or down in the browser it needs to repaint content before it appears onscreen. All being well that will just be a small area, but even if that’s the case the elements that need to be drawn could have complex styles applied. So just because you have a small area to paint doesn't mean it's going to happen quickly.</p>

<p>In order to see what areas are being repainted you can use the “Show Paint Rectangles” feature in Chrome’s DevTools (just hit the little cog in the lower right corner). Then, with DevTools open, simply interact with your page and you’ll see flashing rectangles show where and when Chrome painted a part of your page.</p>

<figure>
  <img src="/static/demos/unnecessary-paints/images/showpaintrects.jpg" />
  <figcaption>Show Paint Rectangles in Chrome DevTools</figcaption>
</figure>

<p>Scrolling performance is critical to your site's success; users really notice when your site or application doesn't scroll well, and they don't like it. We therefore have a vested interest in keeping the paint work light during scrolls so users don't see jank.</p>

<p>I've previously written an <a href="http://www.html5rocks.com/en/tutorials/speed/scrolling/">article on scrolling performance</a>, so take a look at that if you want to know more about the specifics of scrolling performance.</p>

<h2 id="toc-interactions">Interactions</h2>

<p>Interactions are another cause of paint work: hovers, clicks, touches, drags. Whenever the user performs one of those interactions, let's say a hover, then Chrome will have to repaint the affected element. And, much as with scrolling, if there's a large and complex paint required you're going to see the frame rate drop.</p>

<p>Everyone wants nice, smooth, interaction animations, so again we will need to see if the styles that change in our animation are costing us too much time.</p>

<h2 id="toc-combination">残念な組み合わせの一例</h2>

<figure>
  <img src="/static/demos/unnecessary-paints/images/demo.jpg" />
  <figcaption>コストがかかる描画のデモ</figcaption>
</figure>

<p>スクロールしながら同時にマウスを動かしたらどうなるでしょうか。私にとっては、スクロールして通過する要素を<em>うっかりと</em>「触って」しまい、コストのかかる描画処理を開始させてしまうことは非常に良くあります。すると、そのような描画処理のせいで 16.7ms 以内というフレーム制約を超えてしまうこともありえます (60fps を実現するためにはこの 16.7ms という時間以内に収まるようにしなければなりません。) 。何が言いたいかを正確に説明するために、<a href="https://dl.dropboxusercontent.com/u/2272348/codez/expensivescroll/demo.html">デモを作成</a>しました。うまくいけば、スクロールしながらマウスを動かすと、hover エフェクトが作動するのがわかるかと思いますが、Chrome DevToolsがどのように解釈しているかを確認してみましょう。</p>

<figure>
  <img src="/static/demos/unnecessary-paints/images/devtools.png" />
  <figcaption>Chrome DevToolsによるコストがかかるフレームの表示</figcaption>
</figure>

<p>上の画像では、ブロックの 1 つに hover すると描画処理が DevTools に登録されているのが確認できます。デモでは非常に重いスタイルを描画させていたので、ときどきフレーム制約を超えています。特に、他に処理しなければならないことがあるとき、スクロールしながらこの描画処理を不必要に実行させることはどうしても避けたいです。</p>

<p>では、どのようにすればこのような不要な描画処理を止められるのでしょうか。偶然にも、修正を実装するのは非常に簡単です。ここで紹介する方法は、 hover エフェクトを無効にし、再び有効にするタイマーをセットするような <code>scroll</code> ハンドラをセットするというものです。こうすれば、スクロールしているときはコストのかかるインタラクションによる描画処理をする必要がないということを保証できます。十分の時間スクロールをしないと、 hover エフェクトを再び有効にしても問題ないと判断します。</p>

<p class="notice fact">
このような変更は、アプリケーションのユーザエクスペリエンスに影響を与えますので、慎重に判断してください。 hover エフェクトが再度有効になるまでの遅延をどの程度許容するのか判断できるのは、あなたか、あなたのチームだけです。
</p>

<p>コードはこちら:</p>

<pre class="prettyprint"><code>// Used to track the enabling of hover effects
var enableTimer = 0;

/*
 * Listen for a scroll and use that to remove
 * the possibility of hover effects
 */
window.addEventListener('scroll', function() {
  clearTimeout(enableTimer);
  removeHoverClass();

  // enable after 1 second, choose your own value here!
  enableTimer = setTimeout(addHoverClass, 1000);
}, false);

/**
 * Removes the hover class from the body. Hover styles
 * are reliant on this class being present
 */
function removeHoverClass() {
  document.body.classList.remove('hover');
}

/**
 * Adds the hover class to the body. Hover styles
 * are reliant on this class being present
 */
function addHoverClass() {
  document.body.classList.add('hover');
}
</code></pre>

<p>ご覧のとおり、 hover エフェクトが「許可されているかどうか」を追跡するため、 body にある class をつけ、下位のスタイルはこのクラスが存在するかどうかに依存しています。
</p>

<pre class="prettyprint"><code>/* Expect the hover class to be on the body
 before doing any hover effects */
.hover .block:hover {
 …
}
</code></pre>

<p>以上、たったこれだけのことです。</p>

<h2 id="toc-conclusion">まとめ</h2>

<p>レンダリングのパフォーマンスはユーザがあなたのアプリケーションを使用する上でとても重要です。なので、描画に於けるロード時間は16秒以下に保つよう努めなければなりません。それを実現させるサポートとして、起こりうるボトルネックを明確にし、修正する為に開発中はデベロッパーツールを使用するよう徹底するべきです。
</p>

<p>特に、非常に容量が重い要素の描画において、意図しないインタラクションは無駄になり、レンダリングパフォーマンスを損なう可能性があります。あなたがこれまで見てきたように、私たちはそれを修正するために様々なtipsを使用することができるのです。</p>

<p>あなたのサイトやアプリケーションを注意深く見てみてください。もう少し描画を減らしてみてもいいのではないでしょうか。</p>

{% endblock %}
